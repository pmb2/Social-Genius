// Patch node_modules to fix compatibility issues
"use strict";

const fs = require("fs");
const path = require("path");

console.log("Applying node_modules patches...");

// Force disable native modules
process.env.NODE_PG_FORCE_NATIVE = "0";

// Get current directory
const cwd = process.cwd();

// Function to ensure a directory exists
function ensureDir(dirPath) {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
    console.log(`Created directory: ${dirPath}`);
  }
}

// Create a fixes directory
const fixesDir = path.join(cwd, "node_modules", "db-fixes");
ensureDir(fixesDir);

// Fix specific node modules
try {
  // Fix "this.Client is not a constructor" in pg-pool
  const pgPoolDir = path.join(cwd, "node_modules", "pg-pool");
  const pgPoolIndexPath = path.join(pgPoolDir, "index.js");
  
  if (fs.existsSync(pgPoolIndexPath)) {
    // Backup original file
    const pgPoolBackupPath = path.join(fixesDir, "pg-pool-index.js.bak");
    if (!fs.existsSync(pgPoolBackupPath)) {
      fs.copyFileSync(pgPoolIndexPath, pgPoolBackupPath);
      console.log(`Backed up original pg-pool index.js to ${pgPoolBackupPath}`);
    }
    
    let content = fs.readFileSync(pgPoolIndexPath, "utf8");
    
    // Add constructor safety wrapper
    if (!content.includes("if (!(this instanceof Pool))")) {
      console.log("Adding constructor safety wrapper to pg-pool...");
      content = content.replace(
        "module.exports =",
        `// Constructor safety wrapper
module.exports = function(options) {
  if (!(this instanceof Pool)) {
    return new Pool(options);
  }
  return new Pool(options);
};
module.exports.Pool =`
      );
    }
    
    // Fix client constructor in Pool
    if (content.includes("this.Client = options.Client || pg.Client")) {
      console.log("Fixing Client constructor in pg-pool...");
      content = content.replace(
        "this.Client = options.Client || pg.Client",
        `// Ensure Client is always available
this.Client = options.Client || (pg && pg.Client ? pg.Client : function(opts) {
  this.query = () => Promise.resolve({ rows: [] });
  this.connect = () => Promise.resolve();
  this.end = () => Promise.resolve();
});

// Also set Client on prototype for safety
Pool.prototype.Client = this.Client;
Pool.Client = this.Client;`
      );
    }
    
    // Fix newClient method to properly handle missing Client
    if (content.includes("newClient() {")) {
      console.log("Fixing newClient method in pg-pool...");
      content = content.replace(
        /newClient\(\) {[\s\S]*?return (new this\.Client\(.*?\))[\s\S]*?}/,
        `newClient() {
    if (!this.Client) {
      console.log("Fixing missing this.Client in Pool.newClient");
      // Try to load pg.Client as a fallback
      try {
        const pg = require("pg");
        this.Client = pg.Client;
      } catch (e) {
        // Minimal client implementation as a last resort
        this.Client = function(opts) {
          this.query = () => Promise.resolve({ rows: [] });
          this.connect = () => Promise.resolve();
          this.end = () => Promise.resolve();
        };
      }
    }
    
    try {
      return $1;
    } catch (error) {
      console.error("Error creating client in newClient:", error);
      // Fallback to a simple mock client
      return {
        query: () => Promise.resolve({ rows: [] }),
        connect: () => Promise.resolve(),
        end: () => Promise.resolve(),
        release: () => {}
      };
    }
  }`
      );
    }
    
    // Write the fixed content
    fs.writeFileSync(pgPoolIndexPath, content, "utf8");
    console.log("✅ Successfully patched pg-pool module");
  }
  
  // Fix pg module index.js
  const pgDir = path.join(cwd, "node_modules", "pg");
  const pgIndexPath = path.join(pgDir, "index.js");
  
  if (fs.existsSync(pgIndexPath)) {
    // Backup original file
    const pgIndexBackupPath = path.join(fixesDir, "pg-index.js.bak");
    if (!fs.existsSync(pgIndexBackupPath)) {
      fs.copyFileSync(pgIndexPath, pgIndexBackupPath);
      console.log(`Backed up original pg index.js to ${pgIndexBackupPath}`);
    }
    
    // Ensure Pool is properly exported and has Client available
    let pgContent = fs.readFileSync(pgIndexPath, "utf8");
    
    // Add constructor safety to Pool
    if (!pgContent.includes("if (!(this instanceof Pool))")) {
      console.log("Adding constructor safety to pg.Pool...");
      
      // Find where Pool is used/exported
      const poolMatch = pgContent.match(/exports\.Pool\s*=\s*(\w+)/);
      if (poolMatch) {
        const originalPoolName = poolMatch[1];
        pgContent = pgContent.replace(
          `exports.Pool = ${originalPoolName}`,
          `// Constructor safety wrapper
function SafePool(options) {
  if (!(this instanceof SafePool)) {
    return new SafePool(options);
  }
  return new ${originalPoolName}(options);
}

// Copy prototype and properties
Object.setPrototypeOf(SafePool.prototype, ${originalPoolName}.prototype);
Object.setPrototypeOf(SafePool, ${originalPoolName});

// Make sure Client is available
SafePool.prototype.Client = exports.Client;
SafePool.Client = exports.Client;

exports.Pool = SafePool`
        );
      } else {
        // If we can't find the pattern, append a generic Pool wrapper
        pgContent += `
// Constructor safety wrapper
const OriginalPool = exports.Pool;
function SafePool(options) {
  if (!(this instanceof SafePool)) {
    return new SafePool(options);
  }
  return new OriginalPool(options);
}

// Copy prototype and ensure Client is available
if (OriginalPool && OriginalPool.prototype) {
  Object.setPrototypeOf(SafePool.prototype, OriginalPool.prototype);
  Object.setPrototypeOf(SafePool, OriginalPool);
}
SafePool.prototype.Client = exports.Client;
SafePool.Client = exports.Client;

exports.Pool = SafePool;
`;
      }
    }
    
    fs.writeFileSync(pgIndexPath, pgContent, "utf8");
    console.log("✅ Successfully patched pg module");
  }
  
  console.log("Node modules patching completed");
} catch (error) {
  console.error("Error patching node modules:", error);
}
